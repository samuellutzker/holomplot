    fitLine(p,q);
    fitLine(q2,r);
    fitLine(r2,p2);

    if (isOnScreen(p2)) 
        polygon.Append(&p2);
    if (p2 != p && isOnScreen(p))
        polygon.Append(&p);
    if (isOnScreen(q))
        polygon.Append(&q);
    if (q2 != q && isOnScreen(q2))
        polygon.Append(&q2);
    if (isOnScreen(r))
        polygon.Append(&r);
    if (r2 != r && isOnScreen(r2))
        polygon.Append(&r2);
    if (isOnScreen(p2)) 
        polygon.Append(&p2);



bool Canvas::isOnScreen(const wxPoint& p) const {
    return p.x >= 0 && p.y >= 0 && p.x <= scrSize.GetX() && p.y <= scrSize.GetY();
}


// Corrects a line such that it fits on the screen. Returns true if correction occurred.
bool Canvas::fitLine(wxPoint& p, wxPoint& q) {
    if (isOnScreen(p) && isOnScreen(q)) {
        return false;
    }

    if (p.x<0 && q.x<0 || p.x>scrSize.GetX() && q.x>scrSize.GetX()
     || p.y<0 && q.y<0 || p.y>scrSize.GetY() && q.x>scrSize.GetY()) {
        return false;
    }
    
    if (p.x != q.x) {
        double a = ((double)q.y-p.y) / (q.x-p.x);
        int q_x = min(max(q.x, 0), scrSize.GetX());
        q = wxPoint(q_x, a*(q_x-p.x) + p.y);
        int p_x = min(max(p.x, 0), scrSize.GetX());
        p = wxPoint(p_x, a*(p_x-q.x) + q.y);
    }
    if (p.y != q.y) {
        double a = ((double)q.x-p.x) / (q.y-p.y);
        int q_y = min(max(q.y, 0), scrSize.GetY());
        q = wxPoint(a*(q_y-p.y) + p.x, q_y);
        int p_y = min(max(p.y, 0), scrSize.GetY());
        p = wxPoint(a*(p_y-q.y) + q.x, p_y);
    }

    return true;
}